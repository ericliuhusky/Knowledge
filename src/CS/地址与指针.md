# 地址与指针

## UnsafePointer

```swift
let a: Int32 = 3
let ptr = withUnsafePointer(to: a) { $0 }
let addr = UInt(bitPattern: ptr)
print(String(addr, radix: 16))
let ptr2 = UnsafePointer<Int32>(bitPattern: addr)!
let a2 = ptr2.pointee
print(a2)
```

```rust
let a: i32 = 3;
let ptr = &a as *const i32;
let addr = ptr as usize;
println!("{:#x}", addr);
let ptr = addr as *const i32;
let a = unsafe { *ptr };
println!("{}", a);
```

```c
const int a = 3;
const int *ptr = &a;
const long long addr = (long long)ptr;
printf("%llx\n", addr);
const int *ptr2 = (int*)addr;
const int a2 = *ptr2;
printf("%d\n", a2);
```

```asm
// arm64, AT&T

sub sp, sp, #64
stp x29, x30, [sp, #48]
add x29, sp, #48


// int a = 3;
mov w8, #3
str w8, [x29, #-4]

// int *ptr = &a;
sub x8, x29, #4
str x8, [x29, #-16]

// const long long addr = (long long)ptr;
ldr x8, [x29, #-16]
str x8, [x29, #-24]

// const int *ptr2 = (int*)addr;
ldr x8, [x29, #-24]
str x8, [x29, #-32]

// const int a2 = *ptr2;
ldr x8, [x29, #-32]
ldr w8, [x8]
str w8, [x29, #-36]


ldp x29, x30, [sp, #48]
add sp, sp, #64
```

## 内存分配

### 静态内存分配

```swift
let a = 0

struct S {
    static let a = 0
}
```

```rust
static mut A: usize = 0;
```

```c
static int a = 0;
```

```asm
// arm64, AT&T

    .data
_a:
    .quad 0
```

### 栈内存分配

```swift
struct S {
    let a: Int
    let b: Int
    let c: Int
}

func f() {
    let a = 0
    let s = S(a: 1, b: 2, c: 3)
}
```

```rust
struct S {
    a: i32,
    b: i32,
    c: i32,
}

fn f() {
    let a = 0;
    let s = S { a: 1, b: 2, c: 3 };
}
```

```c
struct S {
    int a;
    int b;
    int c;
};

void f() {
    int a = 0;
    struct S s = {1, 2, 3};
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // int a = 0;
    mov w8, #0
    str w8, [x29, #-4*1]

    // struct S s = {1, 2, 3};
    mov w8, #1
    str w8, [x29, #-4*4]
    mov w8, #2
    str w8, [x29, #-4*3]
    mov w8, #3
    str w8, [x29, #-4*2]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

### 堆内存分配

```swift
class C {
    let a: Int
    
    init(a: Int) {
        self.a = a
    }
}

func f() {
    let c = C(a: 1)
}
```

```rust
struct C {
    a: i32,
}

fn f() {
    let c = Box::new(C { a: 1 });
}
```

```c
struct C {
    int a;
};

void f() {
    struct C *c = malloc(sizeof(struct C));
    c->a = 1;
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // struct C *c = malloc(sizeof(struct C));
    mov	x0, #4
    bl _malloc
    str x0, [x29, #-8]

    // c->a = 1;
    mov w8, #1
    ldr x9, [x29, #-8]
    str w8, [x9]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

## 堆内存管理

### 自动引用计数 (ARC)

在编译期间自动向Swift中间语言(sil)中插入引用计数语句，当引用计数为0的时候释放堆内存

```swift
class C {
    let a: Int
    
    init(a: Int) {
        self.a = a
    }
}

func f() {
    let c = C(a: 1)

    sil: strong_retain c : $C
    let c2 = c

    sil: strong_retain c : $C
    let c3 = c

    sil: strong_release c : $C
    sil: strong_release c : $C
    sil: strong_release c : $C
}
```

#### 循环引用

```swift
class A {
    weak var b: B?
}

class B {
    let a: A
    
    init(a: A) {
        self.a = a
    }
}

func f() {
    let a = A()
    let b = B(a: a)
    a.b = b
}
```

```swift
class C {
    var closure: () -> Void = {}

    init() {
        closure = { [weak self] in
            let a = self
        }
    }
}

func f() {
    let c = C()
}
```

### 所有权 (Ownership)

在编译期间根据所有权规则向Rust中间表示层(mir)中插入drop语句，调用drop时释放堆内存

```rust
struct C {
    a: i32,
}

fn f() {
    let c = Box::new(C { a: 1 });
    mir: drop(c);
}
```

#### 循环引用

```rust
struct A {
    b: Option<Weak<B>>,
}

struct B {
    a: Rc<RefCell<A>>,
}

fn f() {
    let a = Rc::new(RefCell::new(A { b: None }));
    let b = Rc::new(B { a: Rc::clone(&a) });
    a.borrow_mut().b = Some(Rc::downgrade(&b));
}
```
