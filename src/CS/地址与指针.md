# 地址与指针

## UnsafePointer

```swift
let a: Int32 = 3
let ptr = withUnsafePointer(to: a) { $0 }
let addr = UInt(bitPattern: ptr)
print(String(addr, radix: 16))
let ptr2 = UnsafePointer<Int32>(bitPattern: addr)!
let a2 = ptr2.pointee
print(a2)
```

```rust
let a: i32 = 3;
let ptr = &a as *const i32;
let addr = ptr as usize;
println!("{:#x}", addr);
let ptr = addr as *const i32;
let a = unsafe { *ptr };
println!("{}", a);
```

```c
const int a = 3;
const int *ptr = &a;
const long long addr = (long long)ptr;
printf("%llx\n", addr);
const int *ptr2 = (int*)addr;
const int a2 = *ptr2;
printf("%d\n", a2);
```

```asm
// arm64, AT&T

sub sp, sp, #64
stp x29, x30, [sp, #48]
add x29, sp, #48


// int a = 3;
mov w8, #3
str w8, [x29, #-4]

// int *ptr = &a;
sub x8, x29, #4
str x8, [x29, #-16]

// const long long addr = (long long)ptr;
ldr x8, [x29, #-16]
str x8, [x29, #-24]

// const int *ptr2 = (int*)addr;
ldr x8, [x29, #-24]
str x8, [x29, #-32]

// const int a2 = *ptr2;
ldr x8, [x29, #-32]
ldr w8, [x8]
str w8, [x29, #-36]


ldp x29, x30, [sp, #48]
add sp, sp, #64
```

## 内存分配

### 静态内存分配

```swift
let a = 0

struct S {
    static let a = 0
}
```

```rust
static mut A: usize = 0;
```

```c
static int a = 0;
```

```asm
// arm64, AT&T

    .data
_a:
    .quad 0
```

### 栈内存分配

```swift
struct S {
    let a: Int
    let b: Int
    let c: Int
}

func f() {
    let a = 0
    let s = S(a: 1, b: 2, c: 3)
}
```

```rust
struct S {
    a: i32,
    b: i32,
    c: i32,
}

fn f() {
    let a = 0;
    let s = S { a: 1, b: 2, c: 3 };
}
```

```c
struct S {
    int a;
    int b;
    int c;
};

void f() {
    int a = 0;
    struct S s = {1, 2, 3};
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // int a = 0;
    mov w8, #0
    str w8, [x29, #-4*1]

    // struct S s = {1, 2, 3};
    mov w8, #1
    str w8, [x29, #-4*4]
    mov w8, #2
    str w8, [x29, #-4*3]
    mov w8, #3
    str w8, [x29, #-4*2]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

### 堆内存分配

```swift
class C {
    let a: Int
    
    init(a: Int) {
        self.a = a
    }
}

func f() {
    let c = C(a: 1)
}
```

```rust
struct C {
    a: i32,
}

fn f() {
    let c = Box::new(C { a: 1 });
}
```

```c
struct C {
    int a;
};

void f() {
    struct C *c = malloc(sizeof(struct C));
    c->a = 1;
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // struct C *c = malloc(sizeof(struct C));
    mov	x0, #4
    bl _malloc
    str x0, [x29, #-8]

    // c->a = 1;
    mov w8, #1
    ldr x9, [x29, #-8]
    str w8, [x9]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

## 堆内存管理

### 自动引用计数 (ARC)

在编译期间自动向Swift中间语言(sil)中插入引用计数语句，当引用计数为0的时候释放堆内存

```swift
class C {
    let a: Int
    
    init(a: Int) {
        self.a = a
    }
}

func f() {
    let c = C(a: 1)

    sil: strong_retain c : $C
    let c2 = c

    sil: strong_retain c : $C
    let c3 = c

    sil: strong_release c : $C
    sil: strong_release c : $C
    sil: strong_release c : $C
}
```

#### 循环引用

```swift
class A {
    weak var b: B?
}

class B {
    let a: A
    
    init(a: A) {
        self.a = a
    }
}

func f() {
    let a = A()
    let b = B(a: a)
    a.b = b
}
```

```swift
class C {
    var closure: () -> Void = {}

    init() {
        closure = { [weak self] in
            let a = self
        }
    }
}

func f() {
    let c = C()
}
```

### 所有权 (Ownership)

在编译期间根据所有权规则向Rust中间表示层(mir)中插入drop语句，调用drop时释放堆内存

```rust
struct C {
    a: i32,
}

fn f() {
    let c = Box::new(C { a: 1 });
    let c2 = c;  mir: c2 = move c;
    let c3 = c2; mir: c3 = move c2;
    mir: drop(c3);
}
```

#### 循环引用

```rust
struct A {
    b: Option<Weak<B>>,
}

struct B {
    a: Rc<RefCell<A>>,
}

fn f() {
    let a = Rc::new(RefCell::new(A { b: None }));
    let b = Rc::new(B { a: Rc::clone(&a) });
    a.borrow_mut().b = Some(Rc::downgrade(&b));
}
```

## 函数传参

### 基础类型

#### 值传递

```swift
func f() {
    let a = 0
    f2(a: a)
}

func f2(a: Int) {

}
```

```rust
fn f() {
    let a = 0;
    f2(a);
}

fn f2(a: i32) {

}
```

```c
void f2(int a) {

}

void f() {
    int a = 0;
    f2(a);
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // int a = 0;
    mov w8, #0
    str w8, [x29, #-4]

    // f2(a);
    ldr x0, [x29, #-4]
    bl _f2


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret

_f2:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

#### 地址/引用传递

```swift
func f() {
    var a = 0
    f2(a: &a)
}

func f2(a: inout Int) {
    a += 1
}
```

```rust
fn f() {
    let mut a = 0;
    f2(&mut a);
    println!("{}", a);
}

fn f2(a: &mut i32) {
    *a += 1;
}
```

```c
void f2(int *a) {
    *a += 1;
}

void f() {
    int a = 0;
    f2(&a);
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // int a = 0;
    mov w8, #0
    str w8, [x29, #-4]

    // f2(&a);
    sub x0, x29, #4
    bl _f2


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret

_f2:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // *a += 1;
    ldr w8, [x0]
    add w8, w8, #1
    str w8, [x0]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

### 栈上复合类型

#### 值传递

```swift
struct S {
    let a: Int
    let b: Int
    let c: Int
}

func f() {
    let s = S(a: 0, b: 0, c: 0)
    f2(s: s)
}

func f2(s: S) {

}
```

```rust
#[derive(Clone)]
struct S {
    a: i32,
    b: i32,
    c: i32,
}

fn f() {
    let s = S { a: 0, b: 0, c: 0 };
    f2(s.clone());
}

fn f2(s: S) {

}
```

```c
struct S {
    int a;
    int b;
    int c;
};

void f2(struct S s) {

}

void f() {
    struct S s = {0, 0, 0};
    f2(s);
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // struct S s = {0, 0, 0};
    mov w8, #0
    str w8, [x29, #-4*3]
    mov w8, #0
    str w8, [x29, #-4*2]
    mov w8, #0
    str w8, [x29, #-4*1]

    // f2(s);
    ldr w8, [x29, #-4*3]
    str w8, [x29, #-4*6]
    ldr w8, [x29, #-4*2]
    str w8, [x29, #-4*5]
    ldr w8, [x29, #-4*1]
    str w8, [x29, #-4*4]

    sub x0, x29, #4*6
    bl _f2


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret

_f2:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

#### 地址/引用传递

```swift
struct S {
    let a: Int
    let b: Int
    let c: Int
}

func f() {
    var s = S(a: 0, b: 0, c: 0)
    f2(s: &s)
}

func f2(s: inout S) {
    s = S(a: 1, b: 1, c: 1)
}
```

```rust
struct S {
    a: i32,
    b: i32,
    c: i32,
}

fn f() {
    let mut s = S { a: 0, b: 0, c: 0 };
    f2(&mut s);
}

fn f2(s: &mut S) {
    *s = S { a: 1, b: 1, c: 1 };
}
```

```c
struct S {
    int a;
    int b;
    int c;
};

void f2(struct S *s) {
    s->a = 1;
    s->b = 1;
    s->c = 1;
}

void f() {
    struct S s = {0, 0, 0};
    f2(&s);
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // struct S s = {0, 0, 0};
    mov w8, #0
    str w8, [x29, #-4*3]
    mov w8, #0
    str w8, [x29, #-4*2]
    mov w8, #0
    str w8, [x29, #-4*1]

    // f2(&s);
    sub x0, x29, #4*3
    bl _f2


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret

_f2:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // s->a = 1;
    mov w8, #1
    str w8, [x0]
    // s->b = 1;
    mov w8, #1
    str w8, [x0, #4]
    // s->c = 1;
    mov w8, #1
    str w8, [x0, #4*2]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

### 堆上复合类型

#### 地址/引用传递

```swift
class C {
    var a: Int

    init(a: Int) {
        self.a = a
    }
}

func f() {
    let c = C(a: 0)
    f2(c: c)
}

func f2(c: C) {
    c.a += 1
}
```

```rust
struct C {
    a: i32,
}

fn f() {
    let mut c = Box::new(C { a: 0 });
    f2(&mut c);
}

fn f2(c: &mut Box<C>) {
    c.a += 1;
}
```

```c
struct C {
    int a;
};

void f2(struct C *c) {
    c->a += 1;
}

void f() {
    struct C *c = malloc(sizeof(struct C));
    c->a = 0;
    f2(c);
}
```

```asm
// arm64, AT&T

_f:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // struct C *c = malloc(sizeof(struct C));
    mov	x0, #4
    bl _malloc
    str x0, [x29, #-8]

    // c->a = 0;
    mov w8, #0
    ldr x9, [x29, #-8]
    str w8, [x9]

    // f2(c);
    ldr x0, [x29, #-8]
    bl _f2


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret

_f2:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // c->a += 1;
    ldr w8, [x0]
    add w8, w8, #1
    str w8, [x0]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```

## 变量赋值

### 基础类型

#### 复制值

```swift
let a = 0
var a2 = a
a2 += 1

// a: 0, a2: 1
```

```rust
let a = 0;
let mut a2 = a;
a2 += 1;

println!("a: {}, a2: {}", a, a2);
```

```c
int a = 0;
int a2 = a;
a2 += 1;

// a: 0, a2: 1
```

```asm
// arm64, AT&T

_main:
    sub sp, sp, #64
    stp x29, x30, [sp, #48]
    add x29, sp, #48


    // int a = 0;
    mov w8, #0
    str w8, [x29, #-4]

    // int a2 = a;
    ldr w8, [x29, #-4]
    str w8, [x29, #-4*2]

    // a2 += 1;
    ldr w8, [x29, #-4*2]
    add w8, w8, #1
    str w8, [x29, #-4*2]


    ldp x29, x30, [sp, #48]
    add sp, sp, #64

    ret
```
